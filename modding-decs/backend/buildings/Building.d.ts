import { DoActionArgs } from "../action/Action";
import { ActionArea, ActionSubcategory } from "../action/ActionAreas";
import { SpellAutocastCategory } from "../autocast/SpellAutocastCategory";
import { GameState } from "../GameState";
import { Identifiable } from "../generic/Identifiable";
import { Resource } from "../Resources";
import { Spell } from "../spells/Spell";
export declare abstract class Building implements Identifiable {
    constructor();
    abstract getId(): string;
    abstract getName(): string;
    abstract getDisplayDescription(state: GameState): string;
    abstract getDisplayEffect(state: GameState): string;
    abstract canTurnOff(): boolean;
    abstract getBaseLandRequired(): number;
    landTags: string[];
    getLandRequired(state: GameState): number;
}
export declare abstract class BuildingSpell extends Spell {
    abstract getBaseResourceCost(): Partial<Record<Resource, number>>;
    abstract getBaseResourceScale(): Partial<Record<Resource, number>>;
    constructor();
    abstract getBuilding(): Building;
    getAutocastCategory(): SpellAutocastCategory;
    canAutoPurchaseMax(): boolean;
    getAreas(): Partial<Record<ActionArea, ActionSubcategory[]>>;
    getSpellName(): string;
    getDisplayName(state: GameState): string;
    getCost(state: GameState): {
        resources: Partial<Record<Resource, number>>;
        items: Record<string, number>;
    };
    getTags(): string[];
    costTags: (key: any) => any[];
    costScaleTags: (key: any) => any[];
    isCappedFromAlternateLand(state: GameState): boolean;
    minCostMultiplierFromMaxCost(state: GameState): number;
    extraLandRequiredForBestCost(state: GameState): number;
    getMinResourceCost(state: GameState): Record<Resource, number>;
    getAlternateLandLowCostScaleMultiplier(): number;
    getResourceCost(state: GameState): Record<Resource, number>;
    getBaseAlternateLandUnawareBuildingAmount(): number;
    canTurnOff(): boolean;
    getDisplayDescription(state: GameState): string;
    getDisplayEffect(state: GameState): string;
    getId(): string;
    doSpellAction(state: GameState, args: DoActionArgs): GameState;
    getBaseManaCost(state: GameState): number;
    canAfford(state: GameState): boolean;
    isCapEnough(state: GameState): boolean;
    doAction(args: DoActionArgs, state: GameState): GameState;
    shouldNeverHaveDemolishBlockers(): boolean;
    shouldNotCountForDemolishBlockers(): boolean;
    getDemolishBlockers(state: GameState): Building[];
    shouldHideDemolish(state: GameState): boolean;
    canDemolish(state: GameState): boolean;
    _demolishUnsafe(state: GameState): GameState;
    demolish(state: GameState): GameState;
    protected shouldIgnoreCanCastSpell(): boolean;
}
